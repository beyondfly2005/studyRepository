> 课程地址：
>
> ​		https://www.bilibili.com/video/BV1R7411774f
>
> ​		https://www.bilibili.com/video/BV1Nf4y1d7KN
>
> 黑马-4天

## 从浅入深精通SpringCloud 微服务架构

## 第零章 学前导读

##### 学习原因

##### 适用群体

- 有一定的Java编程和SpringBoot基础
- 最后有SpringCloud基础

##### 授课方式

- 案例驱动方式讲解
- 用户 商品 订单

##### 课程设计

- 十个章节
- 1-抛出问题 2-解决思路 3-业界方案 4-阿里组件 5-代码实战 6-必要补充

## 第一章 微服务介绍

### 1.1 系统架构演变

随着互联网的发展，网站应用的规模也在不断的扩大，进而导致系统架构也在不断的进行变化。

从互联网早期到现在，系统架构大致经历了下面几个过程：单体应用架构-->垂直应用架构-->分布式架构-->SOA架构-->微服务架构，当然还有悄然兴起的Service Mesh(服务网格化)。

接下来我们就来了解一下每一种架构是什么样子的，已经各自有什么优缺点。

#### 1.1.1 单体应用架构

互联网早期，异步的网站应用流量小，只有一个应用，将所有功能代码都部署在一起就可以，这样可以减少开发、部署和维护的成本。

比如说一个电商系统，；里面会波爱护很多用户管理，商品管理，订单管理，物理管理等待很多模块，我们会把他们做成一个web项目，然后部署到一台tomcat服务器上。

**优点**

- 项目架构简单，小型项目的话，开发成本低
- 项目部署在一个服务器节点上，维护方便

**缺点**

- 全部功能集中在一个工程中，对应大型项目来说，不易于开发和维护
- 项目模块直接紧密耦合，单点容错率低
- 无法针对不同的模块进行针对性优化和水平扩展

#### 1.1.2 垂直应用架构

随着访问量的逐渐增大，单一应用智能以后增加节点来应对（Nginx负载均衡 反向代理），但是这时候会发现并不是所有的模块都会有比较大的访问量。

还以电商为例，用户访问量的增加可能影响的知识用户和订单模块，但是对消息模块的影响就比较小，那么此时我们希望只增加几个订单模块，而不增加消息模块，此时单体应用就做不到了，垂直应用就应运而生。

所谓的垂直应用架构，就是将原来的一个应用拆分为互补想干的几个应用，以提高效率，比如我们可以将上面的电商单体应用拆分为：

- 电商系统（用户管理 商品管理 订单管理）
- 后台系统（用户管理 订单管理 客户管理）
- CMS系统（广告管理 营销管理）

这样拆分完成之后，一旦用户量访问变大，只需要增加电商系统的节点就可以，而无需增加后台系统和CMS的节点。



**优点**

- 系统拆分实现了流量分担，解决了并发问题，而且可以针对不同的模块进行优化和水平扩展
- 一个系统的问题不会影响到其他系统，提高容错率

**缺点**

- 系统之间相互独立，无法进行相互调用
- 系统之间互相独立，会有重复的开发任务

#### 1.1.3 分布式架构

当迟滞应用越来越多，重复的业务代码就会越来越多，这时候，我们就思考可不可以将重复的代码抽取出来，做成统一的业务层作为独立的服务，然后由前端控制层调用不同的业务服务呢？

这就产生了新的分布式系统架构。它将工程拆分为表现层和服务层两个部分，服务层中包含业务逻辑，表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。

**优点**

- 抽取公共的功能作为服务层，提高了代码的复用性

**缺点**

- 系统之间的耦合变高，调用关系错综复杂，难以维护

#### 1.1.4 SOA架构

在分布式架构下，当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现， 此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率 。此时，用于提高机器利用率的 **资源调度和治理中心(SOA Service Oriented Architecture)** 是关键。

**优点**

- 使用了注册中心解决了服务间调用关系的自动调节

**缺点**

- 服务间会有依赖关系，一旦某个环境出错会影响较大（服务雪崩）
- 服务关系复杂，运维、测试部署困难

#### 1.1.5 微服务架构

微服务架构在某种程度上是面向服务的架构SOA继续发展的下一步，它更加强调服务的“彻底拆分”。

**优点**

- 服务原子化拆分，独立打包，部署和升级，保证每个微服务清晰的任务划分，利于扩展
- 微服务之间采用Restful等轻量级http协议互相调用

**缺点**

- 分布式系统开发的技术成本高（容错、分布式事务等）

#### 1.1.6 服务网格化



### 1.2 微服务架构介绍

微服务架构，简单的来说就是将单体应用进一步拆分，拆分成更小的服务，每个服务都是一个可以独立运行的项目。

#### 1.2.1 微服务架构的常见问题

一旦采用微服务系统架构，就势必会遇到这样几个问题：

- 这么多的小服务，如何管理他们？（服务治理 注册中心 服务注册 发现 剔除）
- 这么多的小服务，他们之前间是如何通信的（Restful rpc）
- 这么多的小服务，客户端怎么访问他们？（网关）
- 这么多的小服务，一旦出现问题了，应该如何自处理？（容错）
- 这么多的小服务，一旦出现问题了，应该如何排错？（链路追踪）

对于上面的问题，是任何一个微服务设计者都不能绕过的问题，异常大部分的微服务产都针对每一个问题提供了相应的组件来解决它们。

#### 1.2.2 微服务常见的概念

##### 1.2.2.1 服务治理

服务治理就是进行服务的自动化管理，其核心是服务的注册与发现。

服务注册：服务实例将自身服务信息注册到注册中心

服务发现：服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的的服务。

服务剔除：服务注册中心将出问题服务自动剔除到可用列表之外，使其不能被调用到。

##### 1.2.2.2 服务调用

##### 1.2.2.3 服务网关

##### 1.2.2.4 服务容错

##### 1.2.2.5 链路追踪

#### 1.2.3 微服务架构的常见解决方案

##### 1.2.3.1 ServiceComb

Apache ServiceComb，前身是华为云的微服务引擎CSE(Cloud Service Engine) 云服务，是全球搜歌Apache微服务顶级项目，它听过了一站式的微服务开源解决方案，致力于帮助企业，用户和研发者将企业应用轻松微服务化上云，并实现对微服务英勇的高效运维管理。

##### 1.2.3.2 SpringCloud

##### 1.2.3.3 SpringCloud Alibaba

### 1.3  pringCloud Alibaba 介绍

##### 1.3.1 主要功能

##### 1.3.2 组件

## 第二章 微服务环境搭建

### 2.1 案例设计

##### 2.1.1 技术选型

##### 2.1.2 模块设计

##### 2.13 微服务调用

### 2.2 搭建基础环境

### 2.3 创建基础模块

### 2.4 创建用户微服务

### 2.5 创建商品微服务

### 2.6 创建订单微服务

## 第三章 服务治理

### 3.1 服务治理介绍

### 3.2 nacos简介

### 3.3 nacos 实战入门

#### 3.3.1 nacos 搭建nacos环境

#### 3.3.2 将商品微服务注册到nacos

#### 3.3.3 将订单微服务注册到nacos

### 3.4 实现服务调用的负载均衡

##### 3.4.1 什么是负载均衡

##### 3.4.2 自定义实现负载均衡

##### 3.4.3 基于Ribbon实现负载均衡

### 3.5 基于Feign实现服务调用

##### 3.5.1 什么是Feign

##### 3.5.2 Feign的使用



## 第四章 服务容错

### 4.1 高并发带来的问题

在微服务架构中，我们将业务拆分问一个个的服务，服务于服务之间可以互相调用，但是网络原因或者自身原因，服务并不能保证服务的100%可用，如果单个服务出现问题，调用这个服务就会出现网络延迟，此时若有大量的网络访问涌入，会形成任务堆积，最终导致服务瘫痪。

接下来我们来模拟一个高并发的场景

1 编写java代码

```
public class OrderController2{
	@Autowired
	private OrderService orderService;
	@Autowired
	private ProductService productService;
	
}
```

P30 Sentinel 服务容错



### 4.2 服务雪崩效应

在分布式系统中由于网络原因或自身的原因，服务异步无法保证100%可用。如果一个服务出现了问题，调用这个服务就会出现线程阻塞的情况，此时如有大量的请求涌入，就会出现多条线程阻塞等待，进而导致服务瘫痪。

​		由于服务于服务之间的依赖性，故障会传播，回调整个微服务系统造成灾难性的严重后果，这就是服务故障的"雪崩效应"

### 4.3 常见的容错方案

常见的容错思路：隔离、超时、限流、熔断、降级这几种，下面分别介绍一下。

- **隔离**

  它是指将系统按照一定的原则划分为若干个服务模块，各个模块直接相对独立，无强依赖。当有故障发生时，将问题和影响隔离在某个模块内部，而不扩散风险，不波及其他模块，不影响整体的系统服务，常见的隔离方式有：**线程池隔离和信号量隔离**

- **超时**

  在上游服务调用下游服务的时候，设置一个最大的响应时间，如果超过这个时间，下游未作出反应，就断开请求，是否掉线程

- **限流**



- **熔断**
- 
- **降级**



##### 常用的容错组件

- **Hystrix**
- **Resilience4j**
- **Sentinel**

### 4.4 Semtinel 入门

##### 4.4.1 什么是Sentinel

##### 4.4.2 微服务集成Sentinel

##### 4.4.3 安装Sentinel控制台

##### 4.4.4 实现一个接口的限流



### 4.5 Sentinel的概念和功能

#### 4.5.1 基本概念

#### 4.5.2 重要功能



### 4.6 Sentinel规则

#### 4.6.1 流控规则

##### 4.6.1.1 简单配置

##### 4.6.1.2 配置流控模式

##### 4.6.1.3 配置流控效果



#### 4.6.2 降级规则

#### 4.6.3 热点规则

#### 4.6.4 授权规则

#### 4.6.5 系统规则

### 4.7 @SentinelResource的使用

### 4.8 Sentinel规则持久化 

### 4.9 Feign整合Sentinel



## 第五章 服务网关

#### 5.1 网关简介

大家都知道在微服务架构中，一个系统会被拆分为很多个微服务，那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别取调用。

当前架构下的问题：

1、客户端需要维护服务器的各个地址 代码困难

2、认证鉴权

3、存在跨域请求

#####  什么是API网关

所谓API网关，就是指系统的统一入口，它封装了应用程序的内部结构，为客户端提供统一服务、一些与业务本身功能无关的公共逻辑可言在这里实现，  诸如：认证、鉴权、监控、路由

### 



### P34 服务网关





在业界比较流行的网关，有下面这些

- ##### Nginx+lua

  使用Nginx

- ##### Kong

  基于Nginx+lua开发，性能高，稳定，有多个可用的插件（限流、鉴权）

- ##### Zuul

  Netflix开源的网关，功能丰富，使用Java开发，易于二次开发

  问题：缺乏管控，无法动态配置；依赖组件较多，处理Http请求以来的是web容器

- ##### Spring Cloud GateWay

  Spring公司为了替换Zuul而开发的网关服务，将在下面具体介绍。

注意：SpingCloud Alibaba是没有网关组件的，使用的是SpingCloud





#### P35 SpringCloud Gateway



#### 5.2 Gateway简介

SpringCloud Gateway是Spring公司 



优点：

- 性能强劲：是第一台网关Zuul的1.6倍
- 功能强大
- 设计优雅，易于扩展

##### 缺点：

- 其 实现依赖Netty与WebFlux，不是传统的Servlet编程模型，学习成本高
- 不能将其部署在Tomcat，Jetty等Servlet容器里，只能打成jar包运行
- 需要SpringBoot2.0 以上的版本，才能够支持

### 5.3 Gateway快速入门

#### 5.3.1  基础版

第一步：创建一个api-gateway的模块，并导入相关依赖 pom.xml

千万不要导入springboot-starter-web

```xml

<denpency>
	 <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</denpency>
```

**第二步：** 创建主启动类 ApiGatewayApplication

```java
@SpringBootApplication
public class ApiGatewayApplication{
    public static void main(String[] args){
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```

**第三步** 创建配置文件application.properties

```yml
server:
  port: 7000
spring:
  application:
    name: api-gatewway
cloud:
  gateway:
    routes:
      - id: product-service#当前路由的表示，默认是uuid
        uri: http://localhost:8081 #请求转发的地址
        order: 1 #路由的优先级，数字越小优先级越高
        predicates:  #断言 条件判断 返回值是boolean类型，转发请求要满足的条件
          - Path=/product-service/** #当请求路径满足Path指定的规则是，才会被转发
        filters:  #过滤器 在请求传递过程中 对请求做一些手脚 加入header 
          - StriipPrefix=1  #在请求转发之前去掉一层路径
          
```

#### 5.3.2 增强版

**第一步** 配置文件中加入nacos依赖

```xml
<denpency>
	 <groupId>com.alibaba.cloud</groupId>
    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
</denpency>
```

**第二步** 主程序加入注解

```java
@SpringBootApplication
@EnableDiscoveryClient
public class ApiGatewayApplication{
    public static void main(String[] args){
        SpringApplication.run(ApiGatewayApplication.class, args);
    }
}
```



**第三步** 将微服务地址改为从 nacos中获取

```yaml
server:
  port: 7000
spring:
  application:
    name: api-gatewway
cloud:
  nacos:
    discovery:
      server-addr: localhost:8848 #将gateway注册到nacos
  gateway:
    discovery:
      locator:
        enabled: true # 让gateway从nacos获取信息
    routes:
      - id: product-service#当前路由的表示，默认是uuid
        #uri: http://localhost:8081 #请求转发的地址
        uri: lb://service-product #lb指的是负载均衡，后面跟的是具体微服务在nacos中的标识        
        order: 1 #路由的优先级，数字越小优先级越高
        predicates:  #断言 条件判断 返回值是boolean类型，转发请求要满足的条件
          - Path=/product-service/** #当请求路径满足Path指定的规则是，才会被转发
        filters:  #过滤器 在请求传递过程中 对请求做一些手脚 加入header 
          - StripPrefix=1  #在请求转发之前去掉一层路径
          
```

#### 5.3.3 简写版

不写路由，routes：及其下面的节点 全部注释或者删掉 使用默认的路由规则实现

使用默认的微服务的spring application命名

```yaml
server:
  port: 7000
spring:
  application:
    name: api-gatewway
cloud:
  nacos:
    discovery:
      server-addr: localhost:8848 #将gateway注册到nacos
  gateway:
    discovery:
      locator:
        enabled: true # 让gateway从nacos获取信息
#    routes:
#      - id: product-service#当前路由的表示，默认是uuid
#        #uri: http://localhost:8081 #请求转发的地址
#        uri: lb://service-product #lb指的是负载均衡，后面跟的是具体微服务在nacos中的标识        
#        order: 1 #路由的优先级，数字越小优先级越高
#        predicates:  #断言 条件判断 返回值是boolean类型，转发请求要满足的条件
#          - Path=/product-service/** #当请求路径满足Path指定的规则是，才会被转发
#        filters:  #过滤器 在请求传递过程中 对请求做一些手脚 加入header 
#          - StriipPrefix=1  #在请求转发之前去掉一层路径
```

### 5.4 Gateway核心架构

路由Route是gateway中最基本的组件之一，标识一个具体的路由信息载体，主要定义了下面的几个信息：

- ##### id ,路由标识符 区别其他路由

- **uri，** 路由指定的目的地uri 即客户端请求最终被转发的微服务

- **order,**

- **predicate,**

- **filter,**

## 第六章 服务追踪

## 第七章 

### 第八章

## 第九章

## 第十章

### 